"""
API definitions for blacklist.
"""
import asyncio
from fastapi import Depends
from fastapi_utils.cbv import cbv
from beanie import PydanticObjectId
from fastapi_utils.inferring_router import InferringRouter

from datastore.models.vulnerability import Vulnerability, VulnerabilityRequestSearch, VulnerabilityRequest


router = InferringRouter()


@cbv(router)
class VulnerabilityResource:
    """
    All the views related to Vulnerability.
    """

    model = Vulnerability
    order = [("updated_at", -1), ("title", 1)]

    @router.post("/list")
    async def list_vulnerabilities(
        self,
        req_params: VulnerabilityRequestSearch = VulnerabilityRequestSearch(),
    ):
        """
        List all the vulnerabilities based on the search.
        """
        try:
            query = self.model.find()

            # Filetering on all text fields
            if req_params.search:
                search_query = [
                    {"title": {"$regex": req_params.search, "$options": "i"}},
                    {"impact": {"$regex": req_params.search, "$options": "i"}},
                    {"abstract": {"$regex": req_params.search, "$options": "i"}},
                    {"remediation_recommendation": {"$regex": req_params.search, "$options": "i"}},
                ]
                query = query.find({"or": search_query})

            if req_params.title:
                query = query.find({"title": req_params.title})
            
            if req_params.severity:
                query = query.find({"severity": req_params.severity})

            if req_params.replication_effort:
                query = query.find({"replication_effort": req_params.replication_effort})

            if req_params.remediation_effort:
                query = query.find({"remediation_effort": req_params.remediation_effort})

            data = await query.sort(self.order).skip(req_params.offset).limit(req_params.limit).to_list()
            return dict(
                data=data, success=True, message="Successfully Fetched Vulnerabilities."
            )
        except Exception as e:
            import traceback
            print(traceback.format_exc())
            return dict(data={}, success=False, error="Failed to fetch Vulnerabilities")

    @router.post("/update")
    async def crud_vulnerabilities(
        self,
        data: VulnerabilityRequest = VulnerabilityRequest(),
    ):
        """
        List all the vulnerabilities based on the search.
        """
        msg = ""
        try:
            save_fs, update_fs, delete_fs = [], [], []
            if data.to_save:
                save_fs = Vulnerability.insert_many(
                    list(
                        map(
                            lambda asset: Vulnerability(
                                **asset.dict(),
                            ),
                            data.to_save,
                        )
                    )
                )

            if data.to_delete:
                delete_fs = list(
                    map(
                        lambda asset: Vulnerability.find(
                            Vulnerability.id == asset.id
                        ).delete(),
                        data.to_delete,
                    )
                )

            if data.to_update:
                for d in data.to_update:
                    if not d.id:
                        msg = "Please provide _id to update."
                        raise

                update_fs = list(
                    map(
                        lambda asset: Vulnerability(
                            **asset.dict(),
                        ).save(),
                        data.to_update,
                    )
                )

            await asyncio.gather(*list(filter(bool, [save_fs, *delete_fs, *update_fs])))

            return dict(
                data=data, success=True, message="Successfully Fetched Vulnerabilities."
            )
        except Exception as e:
            import traceback
            print(traceback.format_exc())
            return dict(data={}, success=False, error=f"Operation Failed. {msg}")